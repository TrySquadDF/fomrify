package resolvers

// This file will be automatically regenerated based on the schema, any resolver implementations
// will be copied through when generating and any unknown code will be moved to the end.
// Code generated by github.com/99designs/gqlgen version v0.17.70

import (
	"context"
	"errors"
	"log"
	"time"

	gqlmodel "github.com/TrySquadDF/formify/api-gql/internal/delivery/gql/graph/model"
	gomodel "github.com/TrySquadDF/formify/lib/gomodels"
	"github.com/google/uuid"
	"gorm.io/gorm"
)

func FormsToGraphQL(forms []gomodel.Form) []*gqlmodel.Form {
	result := make([]*gqlmodel.Form, len(forms))
	for i, form := range forms {
		result[i] = FormToGraphQL(&form)
	}
	return result
}

func FormToGraphQL(f *gomodel.Form) *gqlmodel.Form {
    access := gqlmodel.FormAccess(f.Access)
    return &gqlmodel.Form{
        ID:          f.ID,
        OwnerID:     f.OwnerID,
        Title:       f.Title,
        Description: f.Description,
        Access:      access,
        CreatedAt:   f.CreatedAt.Format(time.RFC3339),
        UpdatedAt:   f.UpdatedAt.Format(time.RFC3339),
        Questions:   questionsToGraphQL(f.Questions),
    }
}


func questionToGraphQL(q *gomodel.Question) *gqlmodel.Question {
    return &gqlmodel.Question{
        ID:       q.ID,
        FormID:   q.FormID,
        Text:     q.Text,
        Type:     gqlmodel.QuestionType(q.Type),
        Required: q.Required,
        Order:    q.Order,
        Options:  optionsToGraphQL(q.Options),
    }
}

func questionsToGraphQL(questions []gomodel.Question) []*gqlmodel.Question {
    result := make([]*gqlmodel.Question, len(questions))
    for i, q := range questions {
        result[i] = questionToGraphQL(&q)
    }
    return result
}

func optionsToGraphQL(options []*gomodel.Option) []*gqlmodel.Option {
    result := make([]*gqlmodel.Option, len(options))
    for i, o := range options {
        result[i] = optionToGraphQL(o)
    }
    return result
}

func optionToGraphQL(o *gomodel.Option) *gqlmodel.Option {
    return &gqlmodel.Option{
        ID:         o.ID,
        QuestionID: o.QuestionID,
        Text:       o.Text,
        Order:      o.Order,
    }
}

// CreateForm is the resolver for the createForm field.
func (r *mutationResolver) CreateForm(ctx context.Context, input gqlmodel.FormInput) (*gqlmodel.Form, error) {
	// Get user ID from context
	userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	tx := r.deps.Gorm.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	form := &gomodel.Form{
		ID:          uuid.New().String(),
		OwnerID:     userID,
		Title:       input.Title,
		Description: *input.Description,
		Access:      gomodel.FormAccess(string(*input.Access)),
	}

	if err := tx.Create(form).Error; err != nil {
		tx.Rollback()
		return nil, err
	}

	// Create questions if provided
	if input.Questions != nil {
		for _, qInput := range input.Questions {
			question := gomodel.Question{
				ID:       uuid.New().String(),
				FormID:   form.ID,
				Text:     qInput.Text,
				Type:     gomodel.QuestionType(qInput.Type),
				Required: qInput.Required,
				Order:    qInput.Order,
			}

			if err := tx.Create(&question).Error; err != nil {
				tx.Rollback()
				return nil, err
			}

			// Create options for choice-type questions
			if qInput.Options != nil {
				for _, oInput := range qInput.Options {
					option := gomodel.Option{
						ID:         uuid.New().String(),
						QuestionID: question.ID,
						Text:       oInput.Text,
						Order:      oInput.Order,
					}

					if err := tx.Create(&option).Error; err != nil {
						tx.Rollback()
						return nil, err
					}
				}
			}
		}
	}

	if err := tx.Commit().Error; err != nil {
		return nil, err
	}

	// Fetch the complete form with relations
	var result gomodel.Form
	if err := r.deps.Gorm.Preload("Questions.Options").First(&result, "id = ?", form.ID).Error; err != nil {
		return nil, err
	}

	return FormToGraphQL(&result), nil
}

// UpdateForm is the resolver for the updateForm field.
func (r *mutationResolver) UpdateForm(ctx context.Context, id string, input gqlmodel.FormUpdateInput) (*gqlmodel.Form, error) {
	// Get user ID for authorization
	userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var form gomodel.Form
	if err := r.deps.Gorm.First(&form, "id = ?", id).Error; err != nil {
		return nil, err
	}

	// Check ownership
	if form.OwnerID != userID {
		return nil, errors.New("not authorized to update this form")
	}

	// Begin transaction
	tx := r.deps.Gorm.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	// Update basic form properties
	updates := map[string]interface{}{
		"updatedAt": time.Now(),
	}

	if input.Title != nil {
		updates["title"] = *input.Title
	}
	if input.Description != nil {
		updates["description"] = input.Description
	}
	if input.Access != nil {
		updates["access"] = string(*input.Access)
	}

	if err := tx.Model(&form).Updates(updates).Error; err != nil {
		tx.Rollback()
		return nil, err
	}

	// Handle questions if provided
	if input.Questions != nil {
		// Сначала удаляем все варианты ответов, связанные с вопросами этой формы
		if err := tx.Exec("DELETE FROM options WHERE question_id IN (SELECT id FROM questions WHERE form_id = ?)", id).Error; err != nil {
			tx.Rollback()
			return nil, err
		}

		// Затем удаляем существующие вопросы
		if err := tx.Where("form_id = ?", id).Delete(&gomodel.Question{}).Error; err != nil {
			tx.Rollback()
			return nil, err
		}

		// Create new questions and options
		for _, qInput := range input.Questions {
			question := gomodel.Question{
				ID:       uuid.New().String(),
				FormID:   form.ID,
				Text:     qInput.Text,
				Type:     gomodel.QuestionType(qInput.Type),
				Required: qInput.Required,
				Order:    qInput.Order,
			}

			if err := tx.Create(&question).Error; err != nil {
				tx.Rollback()
				return nil, err
			}

			// Create options for choice-type questions
			if qInput.Options != nil {
				for _, oInput := range qInput.Options {
					option := gomodel.Option{
						ID:         uuid.New().String(),
						QuestionID: question.ID,
						Text:       oInput.Text,
						Order:      oInput.Order,
					}

					if err := tx.Create(&option).Error; err != nil {
						tx.Rollback()
						return nil, err
					}
				}
			}
		}
	}

	if err := tx.Commit().Error; err != nil {
		return nil, err
	}

	// Fetch updated form with all relations
	var result gomodel.Form
	if err := r.deps.Gorm.Preload("Questions.Options").First(&result, "id = ?", id).Error; err != nil {
		return nil, err
	}

	return FormToGraphQL(&result), nil
}

// DeleteForm is the resolver for the deleteForm field.
func (r *mutationResolver) DeleteForm(ctx context.Context, id string) (bool, error) {
    // Get user ID for authorization
    userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)
    if err != nil {
        return false, err
    }

    // Check if form exists and user has permission
    var form gomodel.Form
    if err := r.deps.Gorm.First(&form, "id = ?", id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return false, errors.New("form not found")
        }
        return false, err
    }

    if form.OwnerID != userID {
        return false, errors.New("not authorized to delete this form")
    }

    // Begin transaction
    tx := r.deps.Gorm.Begin()
    defer func() {
        if r := recover(); r != nil {
            tx.Rollback()
        }
    }()

    // 1. Find all questions for this form
    var questions []gomodel.Question
    if err := tx.Where("form_id = ?", id).Find(&questions).Error; err != nil {
        tx.Rollback()
        return false, err
    }

    // Extract question IDs
    questionIDs := make([]string, len(questions))
    for i, q := range questions {
        questionIDs[i] = q.ID
    }

    // 2. Delete answers for all questions in this form
    if len(questionIDs) > 0 {
        if err := tx.Exec("DELETE FROM answers WHERE question_id IN ?", questionIDs).Error; err != nil {
            tx.Rollback()
            return false, err
        }
    }

    // 3. Delete options for each question
    if err := tx.Where("question_id IN ?", questionIDs).Delete(&gomodel.Option{}).Error; err != nil {
        tx.Rollback()
        return false, err
    }

    // 4. Delete questions
    if err := tx.Where("form_id = ?", id).Delete(&gomodel.Question{}).Error; err != nil {
        tx.Rollback()
        return false, err
    }

    // 5. Finally delete the form
    if err := tx.Delete(&gomodel.Form{}, "id = ?", id).Error; err != nil {
        tx.Rollback()
        return false, err
    }

    if err := tx.Commit().Error; err != nil {
        return false, err
    }

    return true, nil
}

func (r *mutationResolver) UpdateQuestion(ctx context.Context, id string, input gqlmodel.QuestionUpdateInput) (*gqlmodel.Question, error) {
	userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var question gomodel.Question
	if err := r.deps.Gorm.First(&question, "id = ?", id).Error; err != nil {
		return nil, err
	}

	var form gomodel.Form
	if err := r.deps.Gorm.First(&form, "id = ?", question.FormID).Error; err != nil {
		return nil, err
	}

	if form.OwnerID != userID {
		return nil, errors.New("not authorized to modify this question")
	}

	tx := r.deps.Gorm.Begin()
	defer func() {
		if r := recover(); r != nil {
			tx.Rollback()
		}
	}()

	updates := map[string]interface{}{}

	if input.Text != nil {
		updates["text"] = *input.Text
	}
	if input.Type != nil {
		updates["type"] = string(*input.Type)
	}
	if input.Required != nil {
		updates["required"] = *input.Required
	}
	if input.Order != nil {
		updates["order"] = *input.Order
	}

	if len(updates) > 0 {
		if err := tx.Model(&question).Updates(updates).Error; err != nil {
			tx.Rollback()
			return nil, err
		}
	}

	if input.Options != nil {
		if err := tx.Where("question_id = ?", id).Delete(&gomodel.Option{}).Error; err != nil {
			tx.Rollback()
			return nil, err
		}

		for _, oInput := range input.Options {
			option := gomodel.Option{
				ID:         uuid.New().String(),
				QuestionID: question.ID,
				Text:       oInput.Text,
				Order:      oInput.Order,
			}

			if err := tx.Create(&option).Error; err != nil {
				tx.Rollback()
				return nil, err
			}
		}
	}

	if err := tx.Commit().Error; err != nil {
		return nil, err
	}

	var result gomodel.Question
	if err := r.deps.Gorm.Preload("Options").First(&result, "id = ?", id).Error; err != nil {
		return nil, err
	}

	return questionToGraphQL(&result), nil
}

func (r *mutationResolver) DeleteQuestion(ctx context.Context, id string) (bool, error) {
	userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	var question gomodel.Question
	if err := r.deps.Gorm.First(&question, "id = ?", id).Error; err != nil {
		return false, err
	}

	var form gomodel.Form
	if err := r.deps.Gorm.First(&form, "id = ?", question.FormID).Error; err != nil {
		return false, err
	}

	if form.OwnerID != userID {
		return false, errors.New("not authorized to delete this question")
	}

	if err := r.deps.Gorm.Delete(&gomodel.Question{}, "id = ?", id).Error; err != nil {
		return false, err
	}

	return true, nil
}

func (r *mutationResolver) UpdateOption(ctx context.Context, id string, input gqlmodel.OptionUpdateInput) (*gqlmodel.Option, error) {
	userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)
	if err != nil {
		return nil, err
	}

	var option gomodel.Option
	if err := r.deps.Gorm.First(&option, "id = ?", id).Error; err != nil {
		return nil, err
	}

	var question gomodel.Question
	if err := r.deps.Gorm.First(&question, "id = ?", option.QuestionID).Error; err != nil {
		return nil, err
	}

	var form gomodel.Form
	if err := r.deps.Gorm.First(&form, "id = ?", question.FormID).Error; err != nil {
		return nil, err
	}

	if form.OwnerID != userID {
		return nil, errors.New("not authorized to modify this option")
	}

	updates := map[string]interface{}{}

	if input.Text != nil {
		updates["text"] = *input.Text
	}
	if input.Order != nil {
		updates["order"] = *input.Order
	}

	if len(updates) > 0 {
		if err := r.deps.Gorm.Model(&option).Updates(updates).Error; err != nil {
			return nil, err
		}
	}

	if err := r.deps.Gorm.First(&option, "id = ?", id).Error; err != nil {
		return nil, err
	}

	return optionToGraphQL(&option), nil
}

func (r *mutationResolver) DeleteOption(ctx context.Context, id string) (bool, error) {
	userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)
	if err != nil {
		return false, err
	}

	var option gomodel.Option
	if err := r.deps.Gorm.First(&option, "id = ?", id).Error; err != nil {
		return false, err
	}

	var question gomodel.Question
	if err := r.deps.Gorm.First(&question, "id = ?", option.QuestionID).Error; err != nil {
		return false, err
	}

	var form gomodel.Form
	if err := r.deps.Gorm.First(&form, "id = ?", question.FormID).Error; err != nil {
		return false, err
	}

	if form.OwnerID != userID {
		return false, errors.New("not authorized to delete this option")
	}

	if err := r.deps.Gorm.Delete(&gomodel.Option{}, "id = ?", id).Error; err != nil {
		return false, err
	}

	return true, nil
}

func (r *queryResolver) Form(ctx context.Context, id string) (*gqlmodel.Form, error) {
    if _, err := uuid.Parse(id); err != nil {
        return nil, errors.New("invalid form ID format")
    }

    var form gomodel.Form
    if err := r.deps.Gorm.Preload("Questions.Options").First(&form, "id = ?", id).Error; err != nil {
        if errors.Is(err, gorm.ErrRecordNotFound) {
            return nil, nil
        }
        return nil, err
    }

	log.Printf("Form: %v", form.Access)
    if form.Access == gomodel.FormAccessPrivate {
        userID, err := r.deps.Sessions.GetUserIDFromContext(ctx)

        if err != nil || userID != form.OwnerID {
            return nil, errors.New("not authorized to access this private form")
        }
    }

    return FormToGraphQL(&form), nil
}

func (r *queryResolver) Forms(ctx context.Context, ownerID *string, access *gqlmodel.FormAccess) ([]*gqlmodel.Form, error) {
	query := r.deps.Gorm.Model(&gomodel.Form{}).Preload("Questions.Options")

	// Apply filters
	if ownerID != nil {
		query = query.Where("owner_id = ?", *ownerID)
	}

	if access != nil {
		query = query.Where("access = ?", string(*access))
	}

	var forms []gomodel.Form
	if err := query.Find(&forms).Error; err != nil {
		return nil, err
	}

	return FormsToGraphQL(forms), nil
}

// !!! WARNING !!!
// The code below was going to be deleted when updating resolvers. It has been copied here so you have
// one last chance to move it out of harms way if you want. There are two reasons this happens:
//  - When renaming or deleting a resolver the old code will be put in here. You can safely delete
//    it when you're done.
//  - You have helper methods in this file. Move them out to keep these resolver files clean.

